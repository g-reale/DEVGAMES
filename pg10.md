# Caderno de 10 páginas  

## Título

![image](https://github.com/g-reale/DEVGAMES/assets/87248285/d99bcf66-3f4d-4fc0-857d-1e70d2add9a7)

## Sistema do jogo desejado
PC

## Público alvo
Livre

## Classificação de idade:
Livre

## Resumo da história do jogo, focando na jogabilidade
A história não é prioridade nesse projeto, dito isso, serão utilizadas temáticas cyberpunk/futuristas ambientadas nas década de 70-90. A seguir segue a **premissa** escrita com a professora Vanessa:

*"Como um entre milhões de hackers de dELTA city, você deve programar seu atômato e assisti-lo em combate até a destruição. Você tem a sagacidade para vencer, ou se tornará apenas mais um na arena?"*

## Os diferentes modos de jogar
O gameplay é dividido em 2 partes:
- programação: escrita do programa para controlar o robô
- combate: com o layout e programa definidos, o robô é colocado na arena, nessa etapa o jogador apenas assiste a batalha entre seu robô e o inimigo.

A estrutura do gameplay permite a exploração de estratégias na programação, de forma que durante o estágio de combate o jogador recebe o feedback de quais idéias são ou não viáveis. Dessa forma o jogador constrói sua propria forma de jogar conforme progride na arena.  

## Diferenciais únicos
 Desafio de programar em uma arquitetura/organização única, enfoque na criação e experimentação de novas estratégias.

## Produtos competidores
- TIS-100
- Shenzen I/O
- Robocode

## Resumo da história
A narrativa não é foco, serão utilizados elementos tipicos de cyberpunk, futuristas e de fição científica para estabelecer uma ambientação mínima. Adicionalmente como se trata de um jogo com elementos de programação, serão utilizados motifs das décadas de 70-90 para que o jogador se sinta programando em um sistema DOS ou semelhante, isto é, o uso do mouse será limitado e a interface será semelhante a de um console como em TIS-100:

![image](https://github.com/g-reale/DEVGAMES/assets/87248285/ccfbeb8f-8a2b-4f28-8815-04296e9748bc)
> interface de programação do jogo TIS-100.

Escolhas artísticas como essas ajudam a contextualizar minimamente sem o uso de uma história
formal. Também será feito o uso de perspectiva 2d, sprites, e artes de terminal ja que esses elementos ressonam com o *feeling* retrô. Note que, as copetências artísticas para esse projeto são limitadas, portanto, será feito uso extensivo de material pronto. 

## O personagem principal
O personagem principal é o computador programado pelo jogador, ele é o agente direto das interações com o mundo.

## Gameplay
O gameplay é o foco, o objetivo é fornecer uma arquitetura/organização restrita para programar o robô, de forma que pequenas tarefas se tornam complexas de serem implementadas em código mas não impossíveis (a idéia é gerar momentos de: "aha! já sei o que daria certo!"). 

O computador proposto é composto de 2 elementos nós e arestas

Nós | Aresta
-|-
Nós contém um programa na linguagem *Statement*| Arestas conectam 2 nós adjacentes, e servem como registradores

Cada nó possuí apenas 4 linhas de código, cada uma atribuí um valor para uma aresta (a,b,c,d) sendo que essas são executadas sequêncialmente. Sempre que um nó escreve em uma aresta, o escopo passa para o nó adjacente.

Para controlar o fluxo de execução/passagem de escopo, será implementado um símbolo de cadeia vazia ($\epsilon$). Quando esse símbolo é escrito em uma aresta não ocorre troca de escopo com o nó conectado.

Um programa em *statement* é composto estritamente de expressões, isto é, cada linha é composta apenas de operadores e operandos, não existem estruturas de laço ou condicionais explicitos. Segue uma lista de alguns dos operadores da linguagem:

- Lógicos (AND, OR, NOT ...)
- Aritméticos (+,-,*,/ ...)
- Condicionais (? operador tenário)
- $\epsilon$ (cadeia vazia impede a execução)

Abaixo segue a janela de edição para _Statment_, é por meio dessa que os nós são programados. Note que na `a>` esta sublinhado em vermelho porque um string vazia não é um programa válido, ou seja, o editor realiza um análise sintática enquanto o usuário digita, note também os 4 rótulos `a> b> c> d>`, cada um desses representa uma aresta diferente.

![image](https://github.com/g-reale/DEVGAMES/assets/87248285/2fd17dda-04e4-4195-8df9-0b4a0389e04a)
> Janela de edição para _Statement_ 

Em um programa válido nenhuma linha é sublinhada em vermelho

![image](https://github.com/g-reale/DEVGAMES/assets/87248285/76efac79-d0f6-47bb-930f-5048e34165a6)
> Janela de edição para _Statement_ com um programa válido

## Níveis/mapa
Abaixo segue o layout simplificado de um nivél. Foram destacados os elemtos principais na imagem:
1. Painel de controle: Esse espaço da tela é dicado para o controle do jogo, assim que o combate for iniciado essa seção conterá os controles da simulação, isto é, o botão iniciar, pausar e parar a simulação
2. Janela da CPU: Esse espaço está reservado para a representação gráfica da CPU, nela o jogador pode observer o nó sendo executado, assim como em qual aresta ele escreve
3. Janela de combate: Nessa tela o jogador acompanha o combate, podendo verificar as ações de seu inimigo e de seu robo

A presença da janela de combate e CPU na mesma tela é importante para que fique claro como a execução do programa se reflete em ações do robô

![image](https://github.com/g-reale/DEVGAMES/assets/87248285/1fa0d08b-51ab-47b5-935a-f1c1e4601f41)

O mapa contém 3 nivéis cada um com um único inimigo, cada inimigo traz um problema de lógica que deve ser resolvido para que o jogo avance. 

**Note que:** Por mais que o layout tenha sido definido, os elementos gráficos (robôs,CPU,GUI) estão abertos para a mudança. Visto o número pequeno de desenvolvedores a arte ainda será mais simplificada

## Inimigos
Como dito, existirão 3 inimigos cada um deles popula uma fase. Para simplificar a arte de forma que ainda exista alguma concordância entre os elementos visuais, inimigos serão representados por caractéres **ASCII** como nos primeiros _roguelikes_ (estética de console):

![image](https://github.com/g-reale/DEVGAMES/assets/87248285/763bc779-0988-40ef-a412-33ba1daf2b8a)
> screenshot de Rogue

![image](https://github.com/g-reale/DEVGAMES/assets/87248285/25d850ec-b755-4ee0-b1d0-ffe9456aae1a)


Para derrotar cada inimigo o jogador deve produzir a saída esperada, isto é trata-se de um problema de decisão, se a saída do programa for idêntica à esperada o inimigo é derrotado, do contrário, o robo do jogador é destruído e o nível reinicia. Abaixo segue as saídas esperadas para cada inimigo:

Inimigo | Saída do programa
-|-
1 | a saída deve ser constante igual a 1 (tutorial)
2 | a saída deve ser composta somente de potências de 2
3 | a saída deve ser composta por números na sequência de fibonacci

## Matriz de combate
Como trata-se de um jogo de puzzle, o "combate" é modulado por dois fatores:

- **Limitação de espaço:** A quantidade de nós de CPU disponiveís ao jogador é limitada, ou seja, a dimenssão espacial do computador é um recurso que deve ser utilizado sabiamente.
- **Limitação de opções:** A linguagem `Statement` é restrita à afirmações o que limita as abordagens disponiveís ao jogador, mais ainda, a ausência de `keywords` de controle de fluxo tornam obrigatório o uso da geometría da CPU para implementar laços e condicionais, isto é, existe um **dilema entre as opções de programação e o espaço do computador**, quanto mais opções menos espaço, quanto menos espaço mais opções.
